package pattern

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

Фабричный метод - это порождающий паттерн, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов

Применимость паттерна:
1. Если заранее неизвестны количество типов и зависимости объектов, то паттерн будет полезен из-за расширяемости
Фабричный метод отделяет код производства продуктов от остального кода, который использует эти продукты.
Благодаря этому код можно расширять, добавляя новые подклассы и удовлетворяя им фабричный интерфейс

2. Когда мы хотим экономить системные ресурсы и не порождать новые лишние объекты, а использовать существующие.

Плюсы:
 Избавляет класс от привязки к конкретным классам продуктов.
 Выделяет код производства продуктов в одно место, упрощая поддержку кода.
 Упрощает добавление новых продуктов в программу.
 Реализует принцип открытости/закрытости.

Минусы:
 Может привести к созданию больших параллельных иерархий классов,
 так как для каждого класса продукта надо создать свой подкласс создателя.

В Go невозможно реализовать классический вариант паттерна Фабричный метод,
поскольку в языке отсутствуют возможности ООП, в том числе классы и наследственность.
Несмотря на это, мы все же можем реализовать базовую версию этого паттерна — Простая фабрика.

*/

// IGun Реализуем интерфейс, который содержит методы будущих пушек
type IGun interface {
	setName(name string)
	setPower(power int)
	getName() string
	getPower() int
}

// Gun Создаем структуру, которая будет имплементировать методы интерфейса IGun

type Gun struct {
	name  string
	power int
}

// Создадим методы Gun для удовлетворения интерфейсу IGun

func (g *Gun) setName(name string) {
	g.name = name
}

func (g *Gun) getName() string {
	return g.name
}

func (g *Gun) setPower(power int) {
	g.power = power
}

func (g *Gun) getPower() int {
	return g.power
}

// Glock подкласс для создания продукта, встроили структуру Gun, передав все существующие методы конкретной пушке
type Glock struct {
	Gun
}

type MP5 struct {
	Gun
}

// Создание пушки
func newGlock() IGun {
	return &Glock{
		Gun{
			name:  "Glock",
			power: 8,
		},
	}
}

func newMP5() IGun {
	return &MP5{
		Gun{
			name:  "MP5",
			power: 10,
		},
	}
}

// GetGun Фабрика возвращает интерфейс пушки
func GetGun(gunType string) (IGun, error) {
	switch {
	case gunType == "Glock":
		return newGlock(), nil
	case gunType == "MP5":
		return newMP5(), nil
	default:
		return nil, fmt.Errorf("Wrong gun type passed!")
	}
}

func FactoryPrint(g IGun) {
	fmt.Printf("Gun is %s\n", g.getName())
	fmt.Printf("Power: %d\n\n", g.getPower())
}
